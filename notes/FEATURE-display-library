# Display the library

Now it's time for the player to start a game.

[] add a "Start Game" button.

When the game starts, we create a Library based on the Deck.

The library is a stack of cards, face-down. To start with, all included cards except the Commander are in the library.

The display of the library is the back of a Magic card (with an effect to make it look like a deep stack) and a count of the number of cards in the library.

For testing purposes, there is also an expandable list of cards in the library, in order. This list is collapsed by default so that you don't see it.

Later, there will be buttons for manipulating the library.

## Keep the whole list of cards, not only the count

In the Deck type, we need to retain a list of every card, not just the count.

[] change the ArchidektDecktoDeck function to keep the list of cards.

In Archidekt, there's a quantity field. We could retain that in our Deck object, but in the Library, we definitely can't; each card will be individual because their order is key. It seems like an optimization to keep the quantity in the Deck, so let's list out each card instead.

## Start a game

When the game starts, we create a Game state. The Game state has a pointer to the Deck. It contains a Library object.

[] create a retrieveDeck function to grab the deck. Right now it'll need to call the Archidekt API again to fetch it, based on the deck number in the input field.

[] create a shuffleDeck method that takes a Deck and returns a Library. The order of the Library is random.

[] create a game-state div. When Start Game is pushed, show the library there.
[] include an End Game button that returns to the state where only deck information & Start Game are shown.
