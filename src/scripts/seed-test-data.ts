/**
 * Seed Test Data
 *
 * Creates test data in the running app by navigating the browser.
 * Writes test/TEST-DATA.md with the resulting IDs and URLs.
 *
 * Run: npm run seed
 * Requires: app running on PORT (default 3344)
 */

import { chromium } from "@playwright/test";
import * as fs from "fs";
import * as path from "path";

const PORT = process.env.PORT || "3344";
const BASE_URL = `http://localhost:${PORT}`;

interface PrepData {
  prepId: string;
  deckName: string;
}

interface GameData {
  gameId: string;
  deckName: string;
  cardsDrawn: number;
}

function extractId(url: string, pattern: RegExp): string {
  const match = url.match(pattern);
  if (!match) throw new Error(`Could not extract ID from URL: ${url}`);
  return match[1];
}

async function selectPreconDeck(page: any): Promise<void> {
  await page.goto(`${BASE_URL}/choose-any-deck`);

  // Wait for HTMX to load the precon tab content
  const firstTile = page.locator(".precon-tile").first();
  await firstTile.waitFor({ state: "visible", timeout: 15000 });

  // The tile is a submit button inside a form POST to /deck.
  // Use page.evaluate to submit the form directly â€” avoids Playwright actionability
  // checks that can block on image loading.
  const deckFile = await firstTile.getAttribute("value");
  console.log(`  Selecting deck: ${deckFile}`);
  await page.evaluate((file: string) => {
    const form = document.querySelector("form.precon-input-section") as HTMLFormElement;
    const input = document.createElement("input");
    input.type = "hidden";
    input.name = "precon-deck";
    input.value = file;
    form.appendChild(input);
    form.submit();
  }, deckFile);
  await page.waitForURL("**/prepare/*", { timeout: 60000 });
}

async function createPrep(page: any): Promise<PrepData> {
  await selectPreconDeck(page);

  const prepId = extractId(page.url(), /\/prepare\/(\d+)/);
  const deckName = await page.locator(".deck-name, h1, h2").first().textContent();

  return { prepId, deckName: deckName?.trim() || "Unknown" };
}

async function createGame(page: any, drawCount: number): Promise<GameData> {
  await selectPreconDeck(page);

  // Get deck name before starting game
  const deckName = await page.locator(".deck-name, h1, h2").first().textContent();

  // Click Shuffle Up
  const shuffleButton = page.locator(
    'button.begin-button, button.start-game-button, button:has-text("Shuffle Up")'
  );
  await shuffleButton.waitFor({ state: "visible", timeout: 10000 });

  await Promise.all([
    page.waitForURL("**/game/*", { timeout: 30000 }),
    shuffleButton.click(),
  ]);

  const gameId = extractId(page.url(), /\/game\/(\d+)/);

  // Draw cards
  for (let i = 0; i < drawCount; i++) {
    const drawButton = page.locator('button:has-text("Draw")');
    await drawButton.waitFor({ state: "visible", timeout: 5000 });
    await drawButton.click();
    // Wait for HTMX to update the page
    await page.waitForLoadState("networkidle");
  }

  return { gameId, deckName: deckName?.trim() || "Unknown", cardsDrawn: drawCount };
}

function writeTestDataFile(prep: PrepData, game: GameData): string {
  const filePath = path.join(__dirname, "../../test/TEST-DATA.md");
  const now = new Date().toISOString().split("T")[0];

  const content = `# Test Data (auto-generated by npm run seed)

Generated: ${now}
Server: ${BASE_URL}

## Prep (deck review, no game started)

- Prep ID: ${prep.prepId}
- Deck: ${prep.deckName}
- Deck review: ${BASE_URL}/prepare/${prep.prepId}
- Library search: ${BASE_URL}/prepare/${prep.prepId}?openLibrary=true

## Game (active, ${game.cardsDrawn} cards drawn)

- Game ID: ${game.gameId}
- Deck: ${game.deckName}
- Game page: ${BASE_URL}/game/${game.gameId}
- Library search: ${BASE_URL}/game/${game.gameId}?openLibrary=true
- Library grouped by type: ${BASE_URL}/game/${game.gameId}?openLibrary=true&groupBy=type
`;

  fs.writeFileSync(filePath, content);
  return filePath;
}

async function main() {
  console.log(`Seeding test data against ${BASE_URL}...`);

  // Verify server is running
  try {
    const response = await fetch(BASE_URL);
    if (!response.ok) throw new Error(`Server returned ${response.status}`);
  } catch (e) {
    console.error(`Server not reachable at ${BASE_URL}. Start it first with: PORT=${PORT} ./run`);
    process.exit(1);
  }

  const browser = await chromium.launch();
  const context = await browser.newContext();

  try {
    const page = await context.newPage();

    // Block external image loading to keep pages fast
    await page.route("**/*.{jpg,jpeg,png,gif,webp}", (route: any) => {
      const url = route.request().url();
      if (url.includes("scryfall") || url.includes("fonts.gstatic")) {
        route.abort();
      } else {
        route.continue();
      }
    });
    await page.route("https://fonts.googleapis.com/**", (route: any) => route.abort());
    await page.route("https://api.honeycomb.io/**", (route: any) => route.abort());

    console.log("Creating prep (deck review)...");
    const prep = await createPrep(page);
    console.log(`  Prep ID: ${prep.prepId} (${prep.deckName})`);

    console.log("Creating game with 7 cards drawn...");
    const game = await createGame(page, 7);
    console.log(`  Game ID: ${game.gameId} (${game.deckName})`);

    const filePath = writeTestDataFile(prep, game);
    console.log(`\nWrote ${filePath}`);
    console.log("Done!");
  } finally {
    await browser.close();
  }
}

main().catch((err) => {
  console.error("Seed failed:", err);
  process.exit(1);
});
